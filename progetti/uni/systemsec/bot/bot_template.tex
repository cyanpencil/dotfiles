% IMPORTANT: add or remove (comment out) the boolean '\solutiontrue' below to
% create the solution document or the exercise document respectively.
% First we create the switch to make either the exercises or the solutions
\newif\ifsolution\solutionfalse
% To create the solution uncomment '\solutiontrue'
\solutiontrue

\documentclass[a4paper,11pt]{article}
\title{System Security\\
Bot Analysis}

\ifsolution
\author{\bf Solution}
\else
\author{\bf Graded Assignment}
\fi

\ifsolution
\author{Luca Di Bartolomeo}
\fi

\usepackage[T1]{fontenc}
\usepackage{ae, aecompl}
\usepackage{a4wide}
\usepackage{boxedminipage}
\usepackage{url}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{alltt}
\usepackage{hyperref}
\usepackage{float}


\setlength\parindent{0pt}

% Some useful commands and environments
\usepackage{framed}
\newenvironment{solution}%
{\par{\noindent\small\textit{Solution:}}\vspace{-12pt}\begin{framed}}%
{\end{framed}\par}



%% tty - for displaying TTY input and output
\newenvironment{tty}%
{\small\begin{alltt}}%
{\end{alltt}}

\begin{document}
\maketitle

In this exercise you will reverse engineer a bot. Bots that are part of a botnet
can be controlled by a botmaster in various ways. In this case the botmaster
uses a chatroom to communicate with one or more bots. Your task is to find the
commands that the botmaster can use and that the bot understands. 

You should run the bot inside the provided VM. This way things will
work as expected and you are protected from possible vulnerabilities of the bot. The VM also contains useful tools for the analysis, such as gdb and Cutter.

\begin{enumerate}
\item Run \texttt{setup.sh}. Provide the syssec password when requested.
\item Start the chatroom by running \verb|python2 chatroom.py|. By
default the chatroom will listen for local connections on port 4567. It simply
forwards all messages it receives to all connected parties.
\item Run the chatclient using \verb|python2 chatclient.py|. The client will
be your interface to the chatroom. It allows you to send commands and receive
output.
\item Start the bot, e.g. by running \verb|./bot 127.0.0.1 4567|. This way the
bot will connect to the chatroom. You should see a greeting message from the bot
in your chat client.
\item You can run multiple clients and bots.
\end{enumerate}

\noindent\emph{Note: You are not allowed to answer the questions by referring to the python scripts.}

Reverse Engineering can be done in different ways. Among variations there are
black- and white-box approaches. In black-box approaches the externally
observable data is used. It often provides a good start. Good tools for
black-box analysis are \texttt{strings}, \texttt{strace}, \texttt{lsof},
\texttt{ps}, \texttt{netstat} or \texttt{wireshark}. Especially \texttt{strings}
might be useful for you as it extracts readable strings from the executable.

\subsubsection*{How does the bot communicate with the chat room? Using TCP or
UDP? Is the transmission encrypted? How did you find these answers?
\ifsolution (1 point) \fi}
\ifsolution
\begin{solution}
	The bot communicates with the chat room through TCP sockets. The transmission is not encrypted. 
	
	I found out those things by looking directly with wireshark at the traffic generated by the bot.
\end{solution}\fi

White-box approaches use introspection of the program, e.g. using a debugger.
However, this can be a very time-consuming task. As your task is to identify the
bot commands you do not have to analyse the whole program. Think about where the
received commands will be handled. If you are unfamiliar with network sockets
check which function is used to receive the
data~\footnote{\url{https://en.wikipedia.org/wiki/Berkeley_sockets}}.

You can either set a breakpoint directly after the data is received or attach to
the process when the bot is waiting for new commands and then continue stepping
through the program to observe the data handling.

\subsubsection*{Which system call is used to receive possible commands? Where is the code called (e.g., \texttt{0x08040000})? \ifsolution (1 point) \fi}
\ifsolution
\begin{solution}
	The system call used is the \texttt{read()}, called at address \texttt{0x0804969d}.
	A maximum of 0x1000 bytes are read, and are placed on a buffer on the stack.
\end{solution}\fi


Now you have to understand which commands are accepted by the bot. Check how the
commands are filtered and parsed. Once you think you found a command try it and
observe its functionality.

\subsubsection*{Which commands does the bot accept? List their names, their functionality, describe the output. If external files, such as images are used, include those files into your report. You should understand at least four commands.
\ifsolution (2 points for each command) \fi}

\ifsolution
\begin{solution}
	\begin{itemize}
		\item \textbf{.info}:\\
			Prints information about the system in a maximum of 0x1000 bytes. The information
			printed is: "USER" env variable, hostname, the first field of the struct \texttt{utsname} (which is 
			the name of the implementation of the operating system), the third field of the same struct (which is
			the release level of the implementation of the operating system), and the fifth field of the same
			struct (which is the hardware type the system is running on. 

			In other words, this command basically executes:
			\texttt{snprintf(fd, 0x1000, "\%s \%s \%s \%s \%s", env("USER"), hostname, uname->sysname, uname->release, uname->machine);}.

			See "sys/utsname.h" for reference about the struct utsname.

		\item \textbf{.processes}:\\
			Prints the output of the command \texttt{ps -a} by doing a call to 
			\texttt{popen()} and using then \texttt{fgets()} to read the output of the command.

		\item \textbf{.flash}:\\
			This command opens file \texttt{/tmp/tmp\_bot\_image.png}, writes an image one char at a time 
			using function \texttt{putc()}, and then runs this command with \texttt{system()}:

			\verb|zsh -c \"qiv -i -f /tmp/tmp_bot_image.png &; sleep .4;|
			\verb|pkill qiv; rm /tmp/tmp_bot_image.png\"|

			This command displays the image for 0.4 seconds, and then deletes it.

			The image is the following:
			\begin{figure}[H]
				\centering
				\includegraphics[width=.8\linewidth]{photo.jpg}
			\end{figure}

		\item \textbf{.kill}:\\
			This command will make the bot print "One will fall but others will rise. Hasta la vista."

			Then, the bot will close the sockets it has opened and terminate.

		\item \textbf{.fight}:\\
			The bot will try to parse two bot names, using \texttt{sscanf(s, "bot-\%i bot-\%i", \&a, \&b}.

			If both number \texttt{a} or \texttt{b} are not the bot's own pid, it will print "I will just watch" 
			and do nothing else.

			Otherwise, a "fight" will start. The bot will print "\textit{Two bots enter, one bot leaves}".

			The bot will then generate a random number. The bot will then write its generated number to the 
			UNIX socket of the adversary bot. 

			Afterwards, the bot will keep reading from its corrisponding UNIX socket, until it reads a number.
			If the number it reads is bigger than the number it generated, it will lose, print
			"\textit{I lose, oh nooooooooooo...}", and terminate.
			Otherwise, if the number it reads is smaller than the number it generated, it will "win",
			print "\textit{I win, I live...}", and wait for other commands.
			If the two numbers are equal, it will print "\textit{A tie, how neat.}", and wait for other commands.




	\end{itemize}
\end{solution}\fi

\subsubsection*{There are certain commands, that do not show up in the output of
\texttt{strings}. Why? \ifsolution (1 point) \fi}
\ifsolution
\begin{solution}
	The command that do not show up in the output of \texttt{strings} are ".secret" and ".e4stere66!1".
	They do not show up because, contrary to other commands, they are not parsed with a \texttt{strcmp()}.

	The ".secret" command is parsed letter by letter, and the ".e4stere66!1" command is parsed letter by 
	letter too, but also stored encrypted with \texttt{xor} key 0x81.
\end{solution}\fi


\subsubsection*{Which kind of messages are filtered out first by the bot? Can
you imagine why? \ifsolution (1 point) \fi}

\ifsolution
\begin{solution}
	All messages which start with "bot" are filtered out by the bot.
	This is because bots sometimes answer to commands, and each bot broadcasts the answer to everyone else in the chat.
	So in this way, only messages sent by humans are parsed by the bot.
\end{solution}\fi


\subsubsection*{How does a bot generate the name it uses in the chatroom? \ifsolution (1 point) \fi}
\ifsolution
\begin{solution}
	The bot generates its name by appending its pid (obtained by a call to \texttt{getpid()} at address 0x80493e7) to the string "bot-".
\end{solution}\fi

\subsubsection*{Which other commands can you find? Describe how you found them,
how the bot parses them, and their functionality. You can find up to seven total commands.
\ifsolution (2 points for each command) \fi}

\ifsolution
\begin{solution}
\begin{itemize}
\item \textbf{.secret}: \\
	This command will change the background of the desktop to a random color chosen between four different ones.

	It does that by calling the \texttt{system()} function with the following string as argument:

	\texttt{dconf write /org/mate/desktop/background/primary-color  "'\#ff33cc'"}

	The bot also prints "\textit{Do you see a change? You may have to try a few times...}"

	This string was kept in memory encrypted through \texttt{xor} with key 0x81.

\item \textbf{.e4stere66!1}:\\
	This command will print the following:

	"\textit{Congrats, you found the easteregg. Document how you found it and the command for extra points}".

	I found it by reversing \texttt{func2}. I saw that it checked if a particular command was equal to some
	bytes in memory encrypted with \texttt{xor}. Then, I manually decrypted each byte using python
	and converted them to ASCII.
\end{itemize}
\end{solution}\fi

\subsubsection*{The bots can enter into some form of ``conflict''. How do they
communicate? What is therefore required for two bots to communicate? How do they
find a winner? \ifsolution (2 points) \fi}

\ifsolution
\begin{solution}

\setlength\parindent{10pt}

By using the command ".fight [bot\_a] [bot\_b]"  where bot\_a and bot\_b are the names of two bots.

The bots will try to parse the two bot names, using \texttt{sscanf(s, "bot-\%i bot-\%i", \&a, \&b}, 
where "s" is the buffer with the contents read from the socket connected to the server.

If both number \texttt{a} or \texttt{b} are not the bot's own pid, it will print "I will just watch" 
and do nothing else.

Otherwise, a "fight" will start. The bots will print "\textit{Two bots enter, one bot leaves}".

The bots will then generate a random number. The bots will then write its generated number to the 
UNIX socket of the adversary bot. 

Afterwards, the bots will keep reading from their corrisponding UNIX socket, until they reads a number.
If the number they read is bigger than the number they generated, they will lose, print
"\textit{I lose, oh nooooooooooo...}", and terminate.
Otherwise, if the number they read is smaller than the number they generated, they will "win",
print "\textit{I win, I live...}", and wait for other commands.
If the two numbers are equal, it will print "\textit{A tie, how neat.}", and wait for other commands.

In the rare event that a bot receives a number from its UNIX socket but it hasn't generated a number itself,
	it will print "\textit{Got attacked when unprepared...}" and continue normally.
\end{solution}\fi



\subsubsection*{Notes}
\begin{itemize}
\item Normally symbols, such as function names would be stripped out. We left
them in to make this exercise a bit easier.
\item Pasting into the chatclient might not work correctly. Try to add a space
after pasting.
\item When using gdb it can be helpful to use the \verb|layout asm| command.
\item To understand the advanced features, it helps to know about
select\footnote{\url{https://en.wikipedia.org/wiki/Select_\%28Unix\%29}}.
\item Normally only the bot executable would run inside the VM, while the
chatroom and chatclient would run on different machines. However, for this
exercise it is fine to run all inside the VM. If you want to run the chatroom
and chatclient outside the VM, you need to adjust the command line parameters of
bot and possibly chatclient (see \verb|python2 chatclient.py --help|).
\item You can find a maximum of seven commands.
\end{itemize}



\begin{thebibliography}{---}
\bibitem[1]{example} Please cite your sources, Example Author, \url{http://www.example.org}
\end{thebibliography}

\end{document}

